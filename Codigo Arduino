int analogPin = 0;
int val = 0;
int leerDatos = 13;
byte crucesCero=0;
int mostrarDatos = 8;

int estadoAC1 = 0;  // Estado para capturar datos
int estadoAC2 = 0;  // Estado para mostrar datos
int capacidad = 200;
int* arr = new int[capacidad];
int i = 0;

bool Cuadrada = false;
bool Senoidal = false;
bool Triangular = false;

float amplitud_anterior = 0;
float frecuencia_anterior = 0;
float frecuencia_actual = 0;

bool Cuadrada_anterior = false;
bool Senoidal_anterior = false;
bool Triangular_anterior = false;

short unsigned int contadores[4] = {0,0,0};

//Variables para medir tiempos
unsigned long tiempo_actual;
int tiempo1 = 0;
int tiempo2 = 0;

LiquidCrystal lcd_1(12, 11, 5, 4, 3, 2);

void setup() {
  lcd_1.begin(16, 2);
  lcd_1.print("Iniciando...");
  Serial.begin(9600);
  pinMode(leerDatos, INPUT);
  pinMode(mostrarDatos, INPUT);
  delay(2000);
  lcd_1.clear();
}

void loop() {
  // Leer el estado del pulsador de capturar datos
  if (digitalRead(leerDatos) == HIGH) {
    estadoAC1 = 1;  // Activar el estado de captura
    estadoAC2 = 0;  // Desactivar el estado de mostrar datos
  }

  // Si está en estado de captura de datos
  if (estadoAC1 == 1) {
    lcd_1.home();
    lcd_1.print("Capturando Datos");

    // Capturar datos, verificar que no se salga del límite de capacidad
    if (i < capacidad) {
      tiempo_actual = millis();
      val = analogRead(analogPin);
      Serial.println(val);
      arr[i] = val;
      
      if(i!=0){
        if(arr[i-1]<0 and arr[i]>=0){
        	crucesCero++;
          	if(crucesCero==1){
          		tiempo1 = tiempo_actual;
          	}
          	else if(crucesCero==2){
          		tiempo2 = tiempo_actual;
              	frecuencia_actual = 1000.0/(tiempo2-tiempo1);
          	}
        }
      }	
      i++;
    } 
    
    if(crucesCero==2) { //Se toman los datos por cada ciclo que haga la señal
      crucesCero = 0; //Se resetea el contador crucesCero
      // Cuando el arreglo está lleno, calcular la amplitud y la frecuencia
      float amplitud_actual = medirAmplitud(arr, i);

      // Detectar el tipo de señal del arreglo actual
      Cuadrada = senalCuadrada(arr, i);
      Senoidal = senalSenoidal(arr, i);
      Triangular = senalTriangular(arr, i);

      // Comparar con el arreglo anterior
      if (amplitud_anterior != 0) {
       	if(frecuencia_actual<=frecuencia_anterior+frecuencia_anterior*0.51 and frecuencia_actual>=frecuencia_anterior-frecuencia_anterior*0.51){
        	if(amplitud_actual<=amplitud_anterior+amplitud_anterior*0.51 and amplitud_actual>=amplitud_anterior-amplitud_anterior*0.51){
            	if (Cuadrada){
					contadores[0]++;
       			 }
        		else if (Senoidal){
					contadores[1]++;
        		}
        		else if (Triangular){
					contadores[2]++;
        		}
        		else{
          			contadores[3]++;
        		}
            }
          	else{
          		contadores[3]++;
          	}
              
        }
        else{
        	contadores[3]++;
        }
      
      }

      // Guardar los datos actuales como los anteriores para la siguiente comparación
      amplitud_anterior = amplitud_actual;
      frecuencia_anterior = frecuencia_actual;
      Cuadrada_anterior = Cuadrada;
      Senoidal_anterior = Senoidal;
      Triangular_anterior = Triangular;

      // Reiniciar el arreglo para capturar nuevos datos
      delete[] arr;
      arr = new int[capacidad];
      i = 0;  // Reiniciar índice para nueva captura
      tiempo_actual = millis();  // Reiniciar el tiempo de captura
    }
  }

  // Verificar si se presiona el pulsador para mostrar datos
  if (digitalRead(mostrarDatos) == HIGH) {
    estadoAC1 = 0;  // Desactivar el estado de captura
    estadoAC2 = 1;  // Activar el estado de mostrar datos
    lcd_1.clear();
  }

  // Si está en estado de mostrar datos
  if (estadoAC2 == 1) {
    lcd_1.setCursor(0, 0);
    lcd_1.print("Tipo de senal");
    lcd_1.setCursor(0, 1);
   
    int indice = indiceMax(contadores,4);
      
    if (indice==0) {
      lcd_1.print("Cuadrada");
    } else if (indice == 1) {
      lcd_1.print("Senoidal");
    } else if (indice == 2) {
      lcd_1.print("Triangular");
    } else if(indice==3) {
      lcd_1.print("Desconocida");
    }
    delay(5000);
    lcd_1.clear();

    // Mostrar frecuencia y amplitud
    if(indice == 0 or indice == 1 or indice == 2){
    	lcd_1.setCursor(0, 0);
    	lcd_1.print("Freq: ");
    	lcd_1.print(frecuencia_anterior);
    	lcd_1.print(" Hz");
    	lcd_1.setCursor(0, 1);
    	lcd_1.print("Amp: ");
    	lcd_1.print(amplitud_anterior);
    	lcd_1.print(" V");
    	delay(5000);
    	lcd_1.clear();
    }

    // Limpiar el arreglo y reiniciar el índice
    delete[] arr;
    arr = new int[capacidad];  // Crear un nuevo arreglo vacío
    i = 0;  // Reiniciar índice para nueva captura
    for(int k=0;k<4;k++){ //resetea el arreglo de contadores
    	contadores[k]=0;
    }

    estadoAC1 = 1;  // Continuar tomando datos
    estadoAC2 = 0;  // Reiniciar el estado de mostrar
    tiempo_actual = millis();
  }
}

// Función para detectar si la señal es cuadrada
bool senalCuadrada(int* arr, int size) {
  int numerosUnicos = 0;
  int unicos[4];

  for (int i = 0; i < size; i++) {
    int j = 0;
    for (j = 0; j < numerosUnicos; j++) {
      if (arr[i] == unicos[j]) {
        j = numerosUnicos;
      }
    }
    if (j == numerosUnicos) {
      unicos[numerosUnicos++] = arr[i];
      if (numerosUnicos > 4) {
        return false;
      }
    }
  }
  return true;
}


// Función para medir la amplitud
float medirAmplitud(int* arr, int size) {
  int valorMaximo = 0;
  int valorMinimo = 1023;

  for (int i = 0; i < size; i++) {
    if (arr[i] > valorMaximo) {
      valorMaximo = arr[i];
    }
    if (arr[i] < valorMinimo) {
      valorMinimo = arr[i];
    }
  }

  float amplitud = (valorMaximo - valorMinimo) * (5.0 / 1023.0);  // Convertir a voltios
  return amplitud;
}


//Funcion de ayuda para sacar la raiz cuadrada
float raizCuadradaAprox(int num) {
  float estimacion = num / 2.0;  // Estimación inicial
  float precision = 0.00001;       // Ajustar la precisión según lo necesario

  // Iterar hasta que la estimación sea suficientemente precisa
  while ((estimacion - num / estimacion) > precision || (num / estimacion - estimacion) > precision) {
    estimacion = (estimacion + num / estimacion) / 2.0;
  }

  return estimacion;
}

int indiceMax(short unsigned int *arr,int size){
  int indice = 0,valorMax = 0,indiceMax=0;
  valorMax = arr[0];
  for(indice;indice<size;indice++){
    if(valorMax<arr[indice]){
    	valorMax = arr[indice];
      	indiceMax = indice;
    }
  }
  return indiceMax;
}

bool senalSenoidal(int* arr, int size) {
  int cambiosSuaves = 0;
  int totalCambios = 0;
  
  for (int i = 1; i < size - 1; i++) {
    int dif1 = arr[i] - arr[i - 1];
    int dif2 = arr[i + 1] - arr[i];
    
    if (abs(dif2 - dif1) < 15) {  // Ajustar umbral
      cambiosSuaves++;
    }
    totalCambios++;
  }

  float proporcionSuave = (float)cambiosSuaves / totalCambios;
  return proporcionSuave > 0.9;  // Ajustar proporción
}

bool senalTriangular(int* arr, int size) {
  int picos = 0;
  int valles = 0;
  int umbralCambio = 15;  // Ajustar umbral
  int tolerancia = 5;     // Ajustar tolerancia

  bool enSubida = false;
  bool enBajada = false;

  for (int i = 1; i < size - 1; i++) {
    int dif1 = arr[i] - arr[i - 1];
    int dif2 = arr[i + 1] - arr[i];

    if ((dif1 > umbralCambio - tolerancia && dif2 < -(umbralCambio - tolerancia)) || 
        (dif1 > umbralCambio && dif2 < -umbralCambio)) {
      picos++;
      enSubida = false;
      enBajada = true;
    } else if ((dif1 < -(umbralCambio - tolerancia) && dif2 > umbralCambio - tolerancia) || 
               (dif1 < -umbralCambio && dif2 > umbralCambio)) {
      valles++;
      enSubida = true;
      enBajada = false;
    }
  }

  float umbralPicosValles = size / 20.0;  // Ajustar umbral dinámico
  return (picos >= umbralPicosValles && valles >= umbralPicosValles);
}

